{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u00b5Detector","text":"<p>\u00b5Detector is an intrusion detection tool for microservice-based applications, written in Python. This tool uses intrusion detection techniques from previous research and automates their functioning for Kubernetes and KubeEdge deployments. The user provides a configuration file and the tool uses monitoring agents to collect system calls from the containers and transfers them over to the IDS module that performs anomaly-based intrusion detection. Anomalous activity will trigger alarms indicating a possible intrusion. The user can interact with the tool and its monitoring capabilities through a command-line interface or a web dashboard.</p> <p>The source code repository can be accessed here: https://github.com/micro-sec/detector.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pre-requisites include a kubernetes cluster setup (for example TeaStore or Sockshop), sysdig (v0.28.0) and a redis server installed and configured</p> <pre><code>git clone https://github.com/micro-sec/detector\ncd detector\npython3 -m pip install -r requirements.txt\npython3 -m pip install -e .\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code># On the master node of the cluster\nkubeproxy\npython3.8 daemon/main.py\n\n# On the worker nodes of the cluster\npython3.8 agent/main.py\n\n# On the local machine that runs the tool\npython3.8 detector/main.py\n</code></pre> <p>Use the CLI or access the Web Dashboard at http://localhost:5001/</p> <p>Tip: Consider using tmux sessions</p>"},{"location":"#about","title":"About","text":"<p>The work presented in this thesis was carried out within the Software and Systems Engineering (SSE) group of the Centre for Informatics and Systems of the University of Coimbra (CISUC)</p> <p>This work is partially supported by the project AIDA: Adaptive, Intelligent and Distributed Assurance Platform FCT (CMU-PT) (POCI-01-0247-FEDER-045907), co-funded by the Portuguese Foundation for Science and Technology (FCT) and by the Fundo Europeu de Desenvolvimento Regional (FEDER) through Portugal 2020: Programa Operacional Competitividade e Internacionaliza\u00e7\u00e3o (POCI).</p> <p>This work has been supervised by Prof. Nuno Antunes and Jos\u00e9 Flora, and presented to the Department of Informatics Engineering of the Faculty of Sciences and Technology of the University of Coimbra.</p> <p>MIT</p>"},{"location":"#publications","title":"Publications","text":"<p>[1] Miguel Teixeira. \u00b5Detector: An Intrusion Detection Tool for Microservices. MSc thesis. 2022. </p> <p>[2] Flora, J., Teixeira, M., Antunes, N., \"\u00b5Detector: Automated Intrusion Detection for Microservices.\" 2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER). IEEE, 2023.</p>"},{"location":"components/","title":"Architecture","text":"<p>The architecture here described represents a more generalized view of the \u00b5Detector tool and how it interacts with the other systems.</p> <p></p> <p>The \u00b5Detector tool interacts with Kubernetes clusters using different technologies. When we refer to the Kubernetes cluster, we also include support for KubeEdge meaning that edge nodes can also be monitored. The communication between the Edge and the Cloud is made through the KubeEdge components CloudCore and EdgeCore.</p> <p>Firstly, to obtain information about the cluster, such as the pods and nodes that are running on the system, and be able to deploy the sysdig probes in the correct nodes, it is necessary to run a Daemon on the master node that will communicate with the tool through REST. Then the user can specify in a JSON file configurations of how the tool should behave when running. For example, the user can specify the services he wants to monitor, the format in which the system calls are collected, the size of the window of collection of system calls and whether the system calls are compressed or not. The configuration file is then validated by the tool and the instructions are sent to the master node (through the daemon) which is responsible for communicating with the monitoring agents (also referred to as \u201cprobes\"). These monitoring agents will then run an instance of sysdig to retrieve the system calls and transfer them to the machine that is running the \u00b5Detector tool where they are temporarily stored in a Redis instance for later use by the IDS module. After the system calls are being monitored (i.e.: extracted from the worker nodes and transferred to the machine that is running the \u00b5Detector tool), the user can spawn intrusion detection instances by providing a configuration file in a JSON format. The configuration file requires a type (training or detection), an algorithm (for example BoSC or STIDE) and a duration (in seconds). When an Intrusion Detection instance is running, the IDS module is responsible for analyzing the system calls according to a certain algorithm and generating a profile if it is a training phase or generating alarms if it is the detection phase and anomalous behavior is detected.</p> <p>The \u00b5Detector tool has two user components that ease the interaction of the user with the tool and improve the observability of the system. These are the CLI and the Web Dashboard. The API Server and the IDS are operations components because they do not interact directly with the user and are responsible instead for the inner workings of the tool.</p> <p>Below we find a screenshot of the main page of \u00b5Detector tool.</p> <p></p> <p>To know more about each component click the following links:</p> <ul> <li> <p>agent</p> </li> <li> <p>daemon</p> </li> <li> <p>detector</p> </li> </ul>"},{"location":"components/agent/","title":"Agent","text":"<p>Each Worker node can have a monitoring agent (also referred to as a \u201cprobe\u201d) running in the background whose job is to collect system calls and transfer them to the external machine that is running the \u00b5Detector tool through Websockets. It is written in Python using the Flask web framework.</p>"},{"location":"components/agent/#agent-api","title":"Agent API","text":"Method URL Description GET / This method always returns 200 and is used to verify that the connection to the agent is working GET /start This method spawns a sysdig process with the parameters from the request data such as filters and args. The system calls collected by this process are then piped to another process responsible for sending them over the network using websockets to the \u00b5Detector tool. Before they are sent, the system calls are grouped in batches defined by a configurable window size which defaults to 5 seconds. This means that every 5 seconds a batch of system calls is sent through over websockets POST /stop This method stops the sysdig and websocket processes that were spawned by the agent in the /start method where the purpose is to stop the collection of system calls"},{"location":"components/daemon/","title":"Daemon","text":"<p>This component is deployed on a Master node of the Kubernetes cluster. It works as a proxy which allows the \u00b5Detector tool, running on an external machine, to communicate with the Kubernetes API to retrieve information about the cluster such as available pods and nodes. Additionally, when a user provides a specific monitoring configuration, the daemon is responsible for communicating with the monitoring agents in the worker nodes. It is written in Python using the Flask web framework.</p>"},{"location":"components/daemon/#daemon-api","title":"Daemon API","text":"Method URL Description GET /status This method always returns 200 and is used to verify that the connection to the daemon is working GET /agents This method is used to verify if the monitoring agents are running on the worker nodes. It returns a JSON with information about the nodes and whether they are running agents or not POST /start This method forwards a POST request to the monitoring agents on the worker nodes to start collecting system calls POST /stop This method forwards a POST request to the monitoring agents on the worker nodes to stop the collection of system calls ANY /proxy Acts as a proxy and allows the tool to access the Kubernetes API and retrieve information about the resources of the cluster"},{"location":"components/detector/","title":"Detector","text":"<p>This folder contains the CLI, Web Dashboard, the API Server and the intrusion detection. The connection to the Local Storage is also established here. The algorithms folder has the implementation of the algorithms (bosc and STIDE). The static folder has static files such as scripts, CSS files, images, etc... that must be sent to the browser when requested. The templates folder has the html (JINJA templates) necessary to present the dashboard to the user. The file main.py is the entrypoint for the Flask app. Some settings can be found in the config.py file and the classes.py contains structures used to agents and configs. The cli.py allows the user to interact with the tool via a command-line interface and the dashboard.py is a blueprint for the web dashboard. The api.py file corresponds to the API Server (and its endpoints) in the tool's architecture. All the other utility functions can be found in the utils.py file.</p>"},{"location":"components/detector/#detector-api","title":"Detector API","text":"Method URL Description GET /api Returns the string \"The detector API\" GET /api/daemon/status Establishes a connection to the Daemon and returns status code 200 GET /api/daemon/agents Establishes a connection to the Daemon and returns a json with information about the nodes and whether they are running agents or not POST /api/monitoring/start Establishes a connection to the Agent and sends a request to start collecting system calls POST /api/monitoring/stop Establishes a connection to the Agent and sends a request to stop collecting system calls POST /api/inspecting/start Starts an intrusion detection instance POST /api/inspecting/stop Stops all intrusion detection instances or a single one if an id is provided GET /api/alarms Returns a list of all the alarms sorted by most recent. It is also possible to retrieve the latest N alarms DELETE /api/alarms Deletes the list of alarms GET /api/algorithms Returns a list of the algorithms available GET /api/resources/pods Returns information about the pods of the Kubernetes cluster GET /api/resources/services Returns information about the services of the Kubernetes cluster GET /api/resources/deployments Returns information about the deployments of the Kubernetes cluster GET /api/resources/namespaces Returns information about the namespaces of the Kubernetes cluster GET /api/nodes Returns information about the nodes of the Kubernetes cluster GET /api/stats Returns a list of all the statistics from the monitoring phase"}]}